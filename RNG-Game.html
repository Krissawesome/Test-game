<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kriss's RNG Game</title>
    <style>
        :root {
            --bg: #0b0b0f;
            --panel: #14141b;
            --panel-border: #2a2a35;
            --accent: #6c5ce7;
            --accent-glow: rgba(108, 92, 231, 0.5);
            --gold: #fdcb6e;
            --gold-glow: rgba(253, 203, 110, 0.6);
            --text-main: #ffffff;
            --text-muted: #a0a0b0;
            --success: #00b894;
            --success-glow: rgba(0, 184, 148, 0.5);
            --danger: #d63031;
            --font: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            --bounce: cubic-bezier(0.34, 1.56, 0.64, 1);
        }

        * { box-sizing: border-box; user-select: none; }
        
        body {
            margin: 0; background-color: var(--bg); color: var(--text-main);
            font-family: var(--font); height: 100vh; overflow: hidden;
            display: flex; flex-direction: column;
        }

        /* --- Header --- */
        header {
            height: 60px; background: var(--panel); border-bottom: 1px solid var(--panel-border);
            padding: 0 20px; display: flex; align-items: center; justify-content: space-between;
            z-index: 20; box-shadow: 0 4px 10px rgba(0,0,0,0.3); flex-shrink: 0;
        }
        .stat-group { display: flex; gap: 25px; }
        .stat { display: flex; flex-direction: column; }
        .stat label { font-size: 0.7rem; color: var(--text-muted); text-transform: uppercase; letter-spacing: 1px; }
        .stat value { font-size: 1.1rem; font-weight: bold; font-variant-numeric: tabular-nums; }
        .currency { color: var(--gold); text-shadow: 0 0 10px rgba(253, 203, 110, 0.2); }

        /* --- Main Stage --- */
        main {
            flex: 1; display: flex; flex-direction: column; align-items: center; justify-content: center;
            position: relative; z-index: 10;
        }

        #aura-display {
            text-align: center; margin-bottom: 30px; opacity: 0;
            transform: scale(0.8); transition: transform 0.4s var(--bounce), opacity 0.3s;
            cursor: help;
        }
        #aura-display.show { opacity: 1; transform: scale(1); }
        #aura-name {
            font-size: 3rem; font-weight: 800; text-transform: uppercase;
            margin: 0; text-shadow: 0 0 30px currentColor;
        }
        #aura-rarity { font-size: 1rem; margin-top: 5px; color: var(--text-muted); }

        /* --- Roll Button & Lucky Mechanics --- */
        #roll-container { position: relative; display: flex; flex-direction: column; align-items: center; }
        
        #roll-btn {
            background: var(--accent); color: white; border: none; padding: 20px 60px;
            font-size: 1.5rem; border-radius: 50px; cursor: pointer; font-weight: bold;
            box-shadow: 0 10px 30px var(--accent-glow);
            transition: all 0.3s var(--bounce);
            z-index: 5;
        }
        #roll-btn:active { transform: scale(0.95); }
        #roll-btn:disabled { background: #333; box-shadow: none; cursor: not-allowed; opacity: 0.7; }
        
        /* Lucky State */
        #roll-btn.lucky {
            background: var(--gold); color: #2d3436;
            box-shadow: 0 0 40px var(--gold-glow), inset 0 0 15px rgba(255,255,255,0.8);
            animation: pulse-gold 1.5s infinite;
        }
        @keyframes pulse-gold { 0% { transform: scale(1); } 50% { transform: scale(1.05); } 100% { transform: scale(1); } }

        #lucky-counter {
            margin-top: 15px; font-size: 0.85rem; font-weight: bold; color: var(--text-muted);
            background: rgba(0,0,0,0.3); padding: 5px 12px; border-radius: 20px;
            transition: all 0.3s; border: 1px solid transparent;
        }
        #lucky-counter.ready {
            color: var(--gold); border-color: var(--gold); background: rgba(253, 203, 110, 0.1);
            text-shadow: 0 0 10px var(--gold-glow);
        }

        /* --- Draggable Panel --- */
        #controls-wrapper {
            background: var(--panel); border-top: 1px solid var(--panel-border);
            display: flex; flex-direction: column; z-index: 30;
            height: 320px; min-height: 200px; max-height: 75vh;
            position: relative; box-shadow: 0 -5px 20px rgba(0,0,0,0.5);
        }

        #resize-handle {
            width: 100%; height: 12px; background: #222; cursor: ns-resize;
            display: flex; justify-content: center; align-items: center;
        }
        #resize-handle::after { content: ''; width: 40px; height: 4px; background: #444; border-radius: 2px; }
        #resize-handle:hover { background: #2a2a35; }

        /* Cooldown Bar */
        #cooldown-container { width: 100%; height: 4px; background: #111; position: relative; }
        #cooldown-bar {
            position: absolute; top: 0; bottom: 0; left: 50%; width: 0;
            background: var(--text-main); transform: translateX(-50%);
            box-shadow: 0 0 10px white; will-change: width;
        }

        /* Tabs & Auto Switch */
        .tabs { display: flex; background: #1a1a20; border-bottom: 1px solid var(--panel-border); align-items: center; }
        .tab-btn {
            flex: 1; padding: 12px; background: none; border: none; color: var(--text-muted);
            cursor: pointer; font-weight: 600; font-size: 0.85rem; border-bottom: 2px solid transparent;
        }
        .tab-btn:hover { color: var(--text-main); background: rgba(255,255,255,0.03); }
        .tab-btn.active { color: var(--accent); border-bottom-color: var(--accent); background: rgba(108, 92, 231, 0.05); }

        /* Auto Toggle */
        #auto-wrapper {
            padding: 0 15px; display: flex; align-items: center; gap: 10px; border-left: 1px solid var(--panel-border); height: 100%;
        }
        .switch { position: relative; display: inline-block; width: 34px; height: 18px; }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider {
            position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0;
            background-color: #333; transition: .4s; border-radius: 34px;
        }
        .slider:before {
            position: absolute; content: ""; height: 12px; width: 12px; left: 3px; bottom: 3px;
            background-color: white; transition: .4s; border-radius: 50%;
        }
        input:checked + .slider { background-color: var(--success); }
        input:checked + .slider:before { transform: translateX(16px); }
        input:disabled + .slider { background-color: #222; cursor: not-allowed; opacity: 0.5; }

        /* --- Tab Content --- */
        .tab-content { flex: 1; position: relative; overflow: hidden; display: none; background: var(--bg); }
        .tab-content.active { display: block; }
        
        .content-scroll { 
            padding: 15px; overflow-y: auto; height: 100%; 
            display: grid; gap: 10px; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            align-content: start;
        }
        #tab-inventory .content-scroll { grid-template-columns: repeat(auto-fill, minmax(160px, 1fr)); }

        /* Cards */
        .card {
            background: rgba(255,255,255,0.03); border: 1px solid rgba(255,255,255,0.05);
            padding: 10px; border-radius: 6px; display: flex; flex-direction: column;
            justify-content: space-between; transition: transform 0.2s var(--bounce);
        }
        .card:hover { transform: translateY(-2px); border-color: rgba(255,255,255,0.1); }
        .card h4 { margin: 0 0 4px 0; color: var(--accent); font-size: 0.9rem; }
        .card p { font-size: 0.75rem; color: var(--text-muted); margin: 0 0 8px 0; line-height: 1.3; }
        .card button {
            background: #333; color: white; border: none; padding: 6px; border-radius: 4px;
            cursor: pointer; width: 100%; font-size: 0.8rem; font-weight: 600; margin-top: auto;
        }
        .card button:hover:not(:disabled) { background: var(--accent); }
        
        .inv-item {
            display: flex; justify-content: space-between; align-items: center;
            background: rgba(0,0,0,0.2); padding: 8px 10px; border-radius: 4px;
            border-left: 3px solid transparent; cursor: help;
        }
        .inv-count { font-weight: bold; color: var(--text-muted); font-size: 0.85rem; }

        /* --- TREE SYSTEM --- */
        #tree-viewport {
            width: 100%; height: 100%; overflow: hidden; position: relative;
            background-image: radial-gradient(#2a2a35 1px, transparent 1px);
            background-size: 20px 20px; cursor: grab;
        }
        #tree-viewport:active { cursor: grabbing; }
        #tree-container { transform-origin: 0 0; position: absolute; top: 0; left: 0; }

        .tree-node {
            position: absolute; width: 44px; height: 44px;
            background: #1a1a1a; border: 2px solid #444; border-radius: 50%;
            display: flex; align-items: center; justify-content: center;
            color: #666; font-weight: bold; cursor: pointer;
            transition: all 0.3s var(--bounce); z-index: 2;
        }
        .tree-node:hover { transform: scale(1.3); z-index: 10; }
        
        /* Node States */
        .tree-node.unlocked { border-color: var(--success); color: var(--success); background: #0f2b23; box-shadow: 0 0 15px var(--success-glow); }
        .tree-node.available { border-color: var(--accent); color: #fff; background: var(--panel); box-shadow: 0 0 10px var(--accent-glow); animation: pulse 2s infinite; }
        
        /* Expansion Node Style */
        .tree-node.expansion {
            width: 54px; height: 54px; border-radius: 8px; border-width: 3px;
            border-color: #e17055; color: #e17055;
        }
        .tree-node.expansion.unlocked { background: #5a2a1e; border-color: #ff7675; color: #ff7675; box-shadow: 0 0 20px rgba(255, 118, 117, 0.4); }

        @keyframes pulse { 0% { box-shadow: 0 0 0 0 var(--accent-glow); } 70% { box-shadow: 0 0 0 8px rgba(0,0,0,0); } 100% { box-shadow: 0 0 0 0 rgba(0,0,0,0); } }

        /* SVG Lines */
        svg.connections { position: absolute; top: 0; left: 0; width: 4000px; height: 4000px; z-index: 1; pointer-events: none; }
        path.conn-line { fill: none; stroke: #333; stroke-width: 3; transition: stroke 0.4s; }
        
        /* Line Colors */
        path.conn-line.owned { stroke: var(--success); opacity: 0.8; }
        path.conn-line.available { stroke: var(--accent); stroke-dasharray: 6; opacity: 0.5; }
        path.conn-line.blocked { stroke: var(--danger); opacity: 0.3; }

        #tree-controls { position: absolute; top: 15px; right: 15px; display: flex; gap: 5px; z-index: 10; }
        .zoom-btn { width: 32px; height: 32px; background: rgba(0,0,0,0.8); border: 1px solid #444; color: white; border-radius: 4px; cursor: pointer; }
        .zoom-btn:hover { background: var(--accent); border-color: var(--accent); }

        /* --- UI Overlays --- */
        #tooltip {
            position: fixed; pointer-events: none; z-index: 9999;
            background: rgba(10, 10, 15, 0.98); border: 1px solid var(--panel-border);
            border-radius: 6px; padding: 12px; min-width: 220px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.9); opacity: 0; transition: opacity 0.1s;
        }
        #tooltip.visible { opacity: 1; }
        #tooltip h3 { margin: 0 0 6px 0; font-size: 1rem; color: white; border-bottom: 1px solid #333; padding-bottom: 6px; }
        #tooltip .row { display: flex; justify-content: space-between; font-size: 0.8rem; color: var(--text-muted); margin-bottom: 3px; }
        #tooltip .val { color: white; font-weight: bold; }
        #tooltip .desc { color: #aaa; margin-top: 8px; font-size: 0.75rem; line-height: 1.4; font-style: italic; }
        #tooltip .cost { margin-top: 8px; font-weight: bold; color: var(--gold); text-align: right; font-size: 0.9rem; border-top: 1px solid #333; padding-top: 5px; }
        #tooltip .cost.locked { color: var(--danger); }

        #active-buffs { position: absolute; top: 20px; left: 20px; display: flex; flex-direction: column; gap: 5px; z-index: 5; }
        .buff { font-size: 0.75rem; color: #000; font-weight: bold; background: var(--success); padding: 4px 8px; border-radius: 4px; box-shadow: 0 2px 10px rgba(0,0,0,0.3); }
        
        #toast-container { position: fixed; bottom: 350px; right: 20px; display: flex; flex-direction: column; gap: 10px; pointer-events: none; z-index: 100; }
        .toast {
            background: rgba(20, 20, 30, 0.95); border-left: 4px solid var(--accent); color: white;
            padding: 10px 20px; border-radius: 4px; animation: slideIn 0.3s var(--bounce);
        }
        @keyframes slideIn { from { transform: translateX(100%); opacity: 0; } to { transform: translateX(0); opacity: 1; } }
    </style>
</head>
<body>

    <header>
        <div class="stat-group">
            <div class="stat">
                <label>Rolls</label>
                <value id="stat-rolls">0</value>
            </div>
            <div class="stat">
                <label>Coins</label>
                <value id="stat-coins" class="currency">0</value>
            </div>
        </div>
        <div class="stat-group">
            <div class="stat" style="text-align: right;">
                <label>Luck</label>
                <value id="stat-luck">1.0x</value>
            </div>
        </div>
    </header>

    <main id="main-stage">
        <div id="active-buffs"></div>

        <div id="aura-display" onmouseenter="Tooltip.showCurrentAura()" onmouseleave="Tooltip.hide()">
            <h1 id="aura-name">Solis RNG</h1>
            <div id="aura-rarity">Begin the Cycle</div>
        </div>

        <div id="roll-container">
            <button id="roll-btn">ROLL</button>
            <div id="lucky-counter">Lucky Roll: 0/10</div>
        </div>
    </main>

    <div id="controls-wrapper">
        <div id="resize-handle"></div>
        <div id="cooldown-container"><div id="cooldown-bar"></div></div>

        <div class="tabs">
            <button class="tab-btn active" onclick="switchTab('inventory')">Auras</button>
            <button class="tab-btn" onclick="switchTab('tree')">Tree</button>
            <button class="tab-btn" onclick="switchTab('shop')">Shop</button>
            <button class="tab-btn" onclick="switchTab('crafting')">Crafting</button>
            
            <div id="auto-wrapper" title="Unlock Auto-Roll in Tree first">
                <span style="font-size:0.75rem; font-weight:bold; color:#888;">AUTO</span>
                <label class="switch">
                    <input type="checkbox" id="auto-check" disabled onchange="Actions.toggleAuto()">
                    <span class="slider"></span>
                </label>
            </div>
        </div>

        <div id="tab-inventory" class="tab-content active"><div class="content-scroll"></div></div>
        
        <div id="tab-tree" class="tab-content" style="background:#0a0a0f;">
            <div id="tree-viewport">
                <div id="tree-controls">
                    <button class="zoom-btn" onclick="Tree.zoom(0.1)">+</button>
                    <button class="zoom-btn" onclick="Tree.zoom(-0.1)">-</button>
                    <button class="zoom-btn" onclick="Tree.reset()">R</button>
                </div>
                <div id="tree-container">
                    <svg class="connections" id="tree-lines"></svg>
                </div>
            </div>
        </div>

        <div id="tab-shop" class="tab-content"><div class="content-scroll"></div></div>
        <div id="tab-crafting" class="tab-content"><div class="content-scroll"></div></div>
    </div>

    <div id="tooltip"></div>
    <div id="toast-container"></div>

<script>
/**
 * Kriss's game
 * - Full Potion/Shop restoration
 * - Expansion Nodes Logic
 * - Green/Red Path Lines
 * - Guaranteed Lucky Roll (10th)
 * - Auto-Roll Toggle
 */

// --- CONFIGURATION ---

const CONFIG = {
    auraCount: 125,
    baseCooldown: 2500,
    luckyThreshold: 10,
    rarityTiers: [
        { name: "Common",     chance: 2,       color: "#b2bec3", coinMult: 1 },
        { name: "Uncommon",   chance: 5,       color: "#81ecec", coinMult: 3 },
        { name: "Rare",       chance: 16,      color: "#0984e3", coinMult: 10 },
        { name: "Epic",       chance: 64,      color: "#6c5ce7", coinMult: 40 },
        { name: "Legendary",  chance: 256,     color: "#fdcb6e", coinMult: 150 },
        { name: "Mythical",   chance: 1024,    color: "#d63031", coinMult: 800 },
        { name: "Divine",     chance: 4096,    color: "#e84393", coinMult: 4000 },
        { name: "Celestial",  chance: 16384,   color: "#00b894", coinMult: 20000 },
        { name: "Godly",      chance: 65536,   color: "#a29bfe", coinMult: 80000 },
        { name: "Zenith",     chance: 1000000, color: "#ffffff", coinMult: 500000 }
    ]
};

const WORDS = {
    prefixes: ["Faded", "Pale", "Bright", "Gilded", "Abyssal", "Solar", "Lunar", "Void", "Star", "Time", "Blood", "Azure", "Crimson", "Neon", "Cyber", "Glitch", "Holy", "Cursed", "Omega", "Alpha", "Eternal", "Broken"],
    suffixes: ["Spark", "Dust", "Flame", "Wave", "Mist", "Stone", "Wind", "Storm", "Pulse", "Shard", "Soul", "Gate", "Matter", "Energy", "Construct", "Dream", "Nightmare", "Singularity", "Essence", "Light", "Darkness"]
};

// --- DATA GENERATION ---

const AURAS = [];
function generateAuras() {
    for (let i = 0; i < CONFIG.auraCount; i++) {
        let tierIdx = 0;
        if(i > 25) tierIdx = 1; if(i > 50) tierIdx = 2; if(i > 70) tierIdx = 3;
        if(i > 85) tierIdx = 4; if(i > 95) tierIdx = 5; if(i > 100) tierIdx = 6;
        if(i > 105) tierIdx = 7; if(i > 110) tierIdx = 8; if(i === 124) tierIdx = 9;

        const tier = CONFIG.rarityTiers[tierIdx];
        const p = WORDS.prefixes[Math.floor(Math.random() * WORDS.prefixes.length)];
        const s = WORDS.suffixes[Math.floor(Math.random() * WORDS.suffixes.length)];
        const uniqueName = i === 124 ? "SOLIS: GENESIS" : `${p} ${s}`;
        const baseOdds = Math.floor(tier.chance * (1 + (i % 5) * 0.15));

        AURAS.push({
            id: `aura_${i}`, name: uniqueName, tier: tierIdx, rarity: baseOdds,
            coins: Math.max(1, Math.floor(tier.coinMult * (1 + Math.random()*0.1))),
            color: tier.color
        });
    }
    AURAS.sort((a, b) => b.rarity - a.rarity);
}
generateAuras();

// --- UPGRADE TREE ---
// Includes Expansion Nodes that hide children until unlocked
const G = 90; // Grid Size
const TREE_NODES = [
    // ROOT
    { id: 'root', x: 0, y: 0, icon: 'ðŸ ', name: "Awakening", cost: 0, parents: [], type: 'root', desc: "Where it all begins." },

    // LUCK PATH (Left)
    { id: 'l1', x: -1*G, y: 0, icon: 'ðŸ€', name: "Luck I", cost: 50, parents: ['root'], type: 'luck', val: 0.1, desc: "+0.1x Luck" },
    { id: 'l2', x: -2*G, y: 0, icon: 'ðŸ€', name: "Luck II", cost: 250, parents: ['l1'], type: 'luck', val: 0.2, desc: "+0.2x Luck" },
    { id: 'l3', x: -3*G, y: 0, icon: 'ðŸ€', name: "Luck III", cost: 1200, parents: ['l2'], type: 'luck', val: 0.3, desc: "+0.3x Luck" },

    // SPEED PATH (Right)
    { id: 's1', x: 1*G, y: 0, icon: 'âš¡', name: "Speed I", cost: 100, parents: ['root'], type: 'speed', val: 0.1, desc: "+10% Roll Speed" },
    { id: 's2', x: 2*G, y: 0, icon: 'âš¡', name: "Speed II", cost: 400, parents: ['s1'], type: 'speed', val: 0.15, desc: "+15% Roll Speed" },
    { id: 'auto', x: 2*G, y: 1*G, icon: 'ðŸ¤–', name: "Auto-Roll", cost: 2500, parents: ['s2'], type: 'unlock_auto', val: 1, desc: "Unlocks Auto-Switch" },
    
    // WEALTH PATH (Down)
    { id: 'c1', x: 0, y: 1*G, icon: 'ðŸ’°', name: "Coins I", cost: 75, parents: ['root'], type: 'coin', val: 0.2, desc: "+20% Coins" },
    { id: 'c2', x: 0, y: 2*G, icon: 'ðŸ’°', name: "Coins II", cost: 350, parents: ['c1'], type: 'coin', val: 0.3, desc: "+30% Coins" },
    
    // --- EXPANSION NODES (Upwards & Special) ---
    // Expansion 1: Void Gate (Up)
    { id: 'exp_void', x: 0, y: -2*G, icon: 'ðŸŒŒ', name: "Void Gate", cost: 5000, parents: ['root'], type: 'expansion', desc: "Reveals Void Path" },
    // Hidden Nodes (Requires exp_void)
    { id: 'v_luck', x: -1*G, y: -3*G, icon: 'ðŸ§¿', name: "Void Luck", cost: 8000, parents: ['exp_void'], type: 'luck', val: 0.5, desc: "+0.5x Luck", reqExp: 'exp_void' },
    { id: 'v_speed', x: 1*G, y: -3*G, icon: 'ðŸš€', name: "Void Speed", cost: 8000, parents: ['exp_void'], type: 'speed', val: 0.3, desc: "+30% Speed", reqExp: 'exp_void' },
    
    // Expansion 2: Golden Throne (Hidden off Wealth)
    { id: 'exp_gold', x: 0, y: 3*G, icon: 'ðŸ‘‘', name: "Gold Throne", cost: 10000, parents: ['c2'], type: 'expansion', desc: "Reveals Royal Path" },
    { id: 'g_lucky', x: 0, y: 4*G, icon: 'ðŸŒŸ', name: "Fortune", cost: 15000, parents: ['exp_gold'], type: 'luck_roll_buff', val: 0.5, desc: "Lucky Roll gives +0.5x Bonus", reqExp: 'exp_gold' }
];

const SHOP_ITEMS = [
    { id: 'pot_luck_s', name: "Minor Luck Potion", cost: 100, duration: 30000, type: 'luck', val: 1.5, desc: "1.5x Luck (30s)" },
    { id: 'pot_luck_l', name: "Major Luck Potion", cost: 500, duration: 60000, type: 'luck', val: 2.5, desc: "2.5x Luck (60s)" },
    { id: 'pot_speed', name: "Haste Vial", cost: 250, duration: 45000, type: 'speed', val: 2.0, desc: "2x Speed (45s)" },
    { id: 'pot_max', name: "Fortune Elixir", cost: 2000, duration: 15000, type: 'luck', val: 5.0, desc: "5.0x Luck (15s)" }
];

const RECIPES = [
    { id: 'r1', output: 'coins', amount: 100, inputTier: 0, count: 10, desc: "10 Common -> 100 Coins" },
    { id: 'r2', output: 'pot_luck_s', inputTier: 1, count: 5, desc: "5 Uncommon -> Minor Luck Pot" },
    { id: 'r3', output: 'gamble_rare', inputTier: 1, count: 10, desc: "10 Uncommon -> Random Rare" },
    { id: 'r4', output: 'pot_speed', inputTier: 2, count: 3, desc: "3 Rare -> Haste Vial" },
    { id: 'r5', output: 'gamble_epic', inputTier: 2, count: 8, desc: "8 Rare -> Random Epic" }
];

// --- STATE ---

let state = {
    rolls: 0,
    coins: 0,
    inventory: {},
    tree: { 'root': true },
    luckyProgress: 0, // 0 to 10
    autoEnabled: false
};

let session = {
    activeBuffs: [],
    lastRollTime: 0,
    currentCooldown: CONFIG.baseCooldown,
    currentAura: null,
    tree: { x: window.innerWidth/2, y: window.innerHeight/3, scale: 1, dragging: false, lx: 0, ly: 0 }
};

// --- LOGIC ---

const RNG = {
    getLuck: () => {
        let mult = 1.0;
        // Tree Upgrades
        TREE_NODES.forEach(n => { if(state.tree[n.id] && n.type==='luck') mult += n.val; });
        
        // Potion Stacking (Max of type)
        const luckPots = session.activeBuffs.filter(b => b.type === 'luck');
        if(luckPots.length > 0) mult *= Math.max(...luckPots.map(p => p.val));
        
        // Lucky Roll Bonus (1.15x Base + Upgrades)
        if(state.luckyProgress >= CONFIG.luckyThreshold) {
            let luckyBonus = 1.15;
            TREE_NODES.forEach(n => { if(state.tree[n.id] && n.type==='luck_roll_buff') luckyBonus += n.val; });
            mult *= luckyBonus;
        }
        
        return mult;
    },
    getSpeedMult: () => {
        let mult = 1.0;
        TREE_NODES.forEach(n => { if(state.tree[n.id] && n.type==='speed') mult += n.val; });
        const speedPots = session.activeBuffs.filter(b => b.type === 'speed');
        if(speedPots.length > 0) mult *= Math.max(...speedPots.map(p => p.val));
        return mult;
    }
};

const Actions = {
    roll: () => {
        const now = Date.now();
        if (now - session.lastRollTime < session.currentCooldown) return;

        session.lastRollTime = now;
        
        // Check Lucky
        const isLucky = state.luckyProgress >= CONFIG.luckyThreshold;

        // RNG Logic
        const luck = RNG.getLuck();
        let result = AURAS[AURAS.length-1]; // Fallback
        
        // Iterate high rarity to low
        for (const aura of AURAS) {
            // formula: if random * (rarity / luck) < 1, you get it
            if (Math.random() * (aura.rarity / luck) < 1) {
                result = aura;
                break;
            }
        }
        
        session.currentAura = result;

        // Coin Logic
        let coinMult = 1.0;
        TREE_NODES.forEach(n => { if(state.tree[n.id] && n.type==='coin') coinMult += n.val; });
        state.coins += Math.floor(result.coins * coinMult);
        state.rolls++;
        state.inventory[result.id] = (state.inventory[result.id] || 0) + 1;

        // Update Lucky Counter
        if(isLucky) {
            state.luckyProgress = 0; // Reset
            UI.toast("Lucky Roll Used!", "success");
        } else {
            state.luckyProgress++;
        }

        UI.animateRoll(result, isLucky);
        UI.updateStats();
        UI.updateInventory(); // Only updates if inventory tab active

        // Cooldown Update
        session.currentCooldown = CONFIG.baseCooldown / RNG.getSpeedMult();
        
        // Button Disable
        const btn = document.getElementById('roll-btn');
        btn.disabled = true;
        setTimeout(() => { 
            if(!state.autoEnabled) btn.disabled = false; 
        }, session.currentCooldown);
    },

    toggleAuto: () => {
        // Can only toggle if unlocked
        if (!state.tree['auto']) return;
        
        const checkbox = document.getElementById('auto-check');
        state.autoEnabled = checkbox.checked;
        
        if(state.autoEnabled) UI.toast("Auto-Roll Active", "success");
        else UI.toast("Auto-Roll Paused");
    },

    buyNode: (id) => {
        if(state.tree[id]) return;
        const node = TREE_NODES.find(n => n.id === id);
        
        // Check Parents
        const parentsMet = node.parents.every(p => state.tree[p]);
        if(!parentsMet) { UI.toast("Locked path!", "error"); return; }
        
        if(state.coins < node.cost) { UI.toast("Not enough coins!", "error"); return; }

        state.coins -= node.cost;
        state.tree[id] = true;
        
        // Specials
        if(node.type === 'unlock_auto') {
             document.getElementById('auto-check').disabled = false;
             UI.toast("Auto-Roll Unlocked!", "success");
        } else if(node.type === 'expansion') {
             UI.toast("New Area Revealed!", "success");
        } else {
            UI.toast(`${node.name} Acquired!`, "success");
        }

        UI.updateStats();
        Tree.render(); // Redraw lines
    },

    buyShop: (id) => {
        const item = SHOP_ITEMS.find(i => i.id === id);
        if(state.coins >= item.cost) {
            state.coins -= item.cost;
            // Potion Logic: Stack Duration if same name
            const existing = session.activeBuffs.find(b => b.name === item.name);
            if(existing) {
                existing.expireTime += item.duration;
                UI.toast(`${item.name} Extended!`);
            } else {
                session.activeBuffs.push({ 
                    type: item.type, val: item.val, name: item.name, expireTime: Date.now() + item.duration 
                });
                UI.toast(`${item.name} Active!`, "success");
            }
            UI.updateStats();
            UI.renderBuffs();
        } else {
            UI.toast("Need more coins", "error");
        }
    },
    
    craft: (rid) => {
        const rcp = RECIPES.find(r => r.id === rid);
        const invAuras = AURAS.filter(a => a.tier === rcp.inputTier);
        let needed = rcp.count;
        let consumed = {};

        // Auto-select auras to consume
        for(let a of invAuras) {
            let has = state.inventory[a.id] || 0;
            if(has > 0) {
                let take = Math.min(has, needed);
                consumed[a.id] = take;
                needed -= take;
                if(needed <= 0) break;
            }
        }

        if(needed > 0) { UI.toast(`Need ${rcp.count} Tier ${rcp.inputTier} Auras`, "error"); return; }

        // Remove items
        for(let id in consumed) state.inventory[id] -= consumed[id];
        
        // Give Reward
        if(rcp.output === 'coins') { 
            state.coins += rcp.amount; 
            UI.toast(`+${rcp.amount} Coins`); 
        } else if (rcp.output.startsWith('gamble')) {
             const tier = rcp.output === 'gamble_rare' ? 2 : 3;
             const pool = AURAS.filter(a => a.tier === tier);
             const res = pool[Math.floor(Math.random()*pool.length)];
             state.inventory[res.id] = (state.inventory[res.id] || 0) + 1;
             UI.toast(`Crafted: ${res.name}`, "success");
        } else {
            // Potion
            const item = SHOP_ITEMS.find(i => i.id === rcp.output);
            if(item) {
                const existing = session.activeBuffs.find(b => b.name === item.name);
                if(existing) existing.expireTime += item.duration;
                else session.activeBuffs.push({ type: item.type, val: item.val, name: item.name, expireTime: Date.now() + item.duration });
                UI.toast("Potion Brewed!", "success");
            }
        }
        UI.updateStats();
        UI.updateInventory();
    }
};

// --- VISUALS & TREE ---

const Resizer = {
    init: () => {
        const h = document.getElementById('resize-handle');
        const p = document.getElementById('controls-wrapper');
        let isResizing = false;
        
        h.addEventListener('mousedown', (e) => {
            isResizing = true; e.preventDefault();
        });
        window.addEventListener('mouseup', () => isResizing = false);
        window.addEventListener('mousemove', (e) => {
            if(!isResizing) return;
            const h = window.innerHeight - e.clientY;
            p.style.height = Math.max(200, Math.min(window.innerHeight*0.75, h)) + 'px';
        });
    }
};

const Tree = {
    init: () => {
        const vp = document.getElementById('tree-viewport');
        vp.addEventListener('mousedown', e => {
            if(e.target.closest('.tree-node')) return;
            session.tree.dragging = true;
            session.tree.lx = e.clientX; session.tree.ly = e.clientY;
        });
        window.addEventListener('mouseup', () => session.tree.dragging = false);
        window.addEventListener('mousemove', e => {
            if(!session.tree.dragging) return;
            session.tree.x += e.clientX - session.tree.lx;
            session.tree.y += e.clientY - session.tree.ly;
            session.tree.lx = e.clientX; session.tree.ly = e.clientY;
            Tree.apply();
        });
        vp.addEventListener('wheel', e => { e.preventDefault(); Tree.zoom(e.deltaY > 0 ? -0.1 : 0.1); });
        Tree.render();
        Tree.apply();
    },
    zoom: (d) => {
        session.tree.scale = Math.max(0.4, Math.min(2.0, session.tree.scale + d));
        Tree.apply();
    },
    reset: () => {
        session.tree = { x: window.innerWidth/2, y: window.innerHeight/3, scale: 1, dragging: false, lx: 0, ly: 0 };
        Tree.apply();
    },
    apply: () => {
        document.getElementById('tree-container').style.transform = 
            `translate(${session.tree.x}px, ${session.tree.y}px) scale(${session.tree.scale})`;
    },
    render: () => {
        const svg = document.getElementById('tree-lines');
        const cont = document.getElementById('tree-container');
        
        // Clear old
        Array.from(cont.querySelectorAll('.tree-node')).forEach(e => e.remove());
        svg.innerHTML = "";

        // 1. Filter Nodes based on Expansion Logic
        // A node is visible if it has no reqExp OR if the reqExp node is bought
        const visibleNodes = TREE_NODES.filter(n => !n.reqExp || state.tree[n.reqExp]);

        visibleNodes.forEach(node => {
            // 2. Draw Lines to Parents
            node.parents.forEach(pid => {
                const p = TREE_NODES.find(n => n.id === pid);
                if(!p || !visibleNodes.includes(p)) return; // Don't draw line if parent hidden

                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                // Offset +22 (half of 44px) or +27 (half of 54px expansion)
                const off1 = p.type === 'expansion' ? 27 : 22;
                const off2 = node.type === 'expansion' ? 27 : 22;

                path.setAttribute('d', `M${p.x + off1} ${p.y + off1} L${node.x + off2} ${node.y + off2}`);
                
                // Class Logic for Green/Red Lines
                let lineClass = 'conn-line';
                if(state.tree[node.id]) {
                    lineClass += ' owned'; // Green
                } else if(state.tree[p.id]) {
                    // Parent owned, check affordability
                    if(state.coins >= node.cost) lineClass += ' available'; // Yellow/Dash
                    else lineClass += ' blocked'; // Red
                }
                
                path.setAttribute('class', lineClass);
                svg.appendChild(path);
            });

            // 3. Draw Node
            const el = document.createElement('div');
            const owned = state.tree[node.id];
            const parentsMet = node.parents.every(pid => state.tree[pid]);
            
            let cls = 'tree-node';
            if(node.type === 'expansion') cls += ' expansion';
            
            if(owned) cls += ' unlocked';
            else if(parentsMet) cls += ' available';
            
            el.className = cls;
            el.style.left = node.x + 'px';
            el.style.top = node.y + 'px';
            el.innerHTML = `<i>${node.icon}</i>`;
            
            el.onclick = (e) => { e.stopPropagation(); Actions.buyNode(node.id); };
            
            el.onmouseenter = () => {
                const color = owned ? '#00b894' : (parentsMet ? (state.coins>=node.cost ? '#fdcb6e' : '#d63031') : '#555');
                Tooltip.show(node.name, [{label:'Effect',val:node.desc}], color, owned?"Owned":node.cost, !parentsMet);
            };
            el.onmouseleave = Tooltip.hide;
            
            cont.appendChild(el);
        });
    }
};

const Tooltip = {
    el: document.getElementById('tooltip'),
    show: (title, rows, color, cost=null, locked=false) => {
        Tooltip.el.style.borderColor = color;
        let html = `<h3 style="color:${color}">${title}</h3>`;
        rows.forEach(r => html += `<div class="row"><span>${r.label}</span><span class="val">${r.val}</span></div>`);
        if(cost) html += `<div class="cost ${locked?'locked':''}">${cost} Coins</div>`;
        Tooltip.el.innerHTML = html;
        Tooltip.el.classList.add('visible');
    },
    hide: () => Tooltip.el.classList.remove('visible'),
    move: (e) => {
        if(!Tooltip.el.classList.contains('visible')) return;
        Tooltip.el.style.left = Math.min(window.innerWidth - 240, e.clientX + 15) + 'px';
        Tooltip.el.style.top = Math.min(window.innerHeight - 150, e.clientY + 15) + 'px';
    },
    showCurrentAura: () => {
        if(!session.currentAura) return;
        const a = session.currentAura;
        Tooltip.show(a.name, [
            {label:"Rarity", val:CONFIG.rarityTiers[a.tier].name},
            {label:"Chance", val:`1 in ${a.rarity.toLocaleString()}`},
            {label:"Value", val:a.coins}
        ], a.color);
    }
};

const UI = {
    init: () => {
        Resizer.init();
        Tree.init();
        UI.renderStaticTabs();
        document.getElementById('roll-btn').onclick = Actions.roll;
        document.addEventListener('mousemove', Tooltip.move);
        
        // Restore State check
        if(state.tree['auto']) document.getElementById('auto-check').disabled = false;
        
        GameLoop.start();
    },
    updateStats: () => {
        document.getElementById('stat-rolls').innerText = state.rolls.toLocaleString();
        document.getElementById('stat-coins').innerText = state.coins.toLocaleString();
        document.getElementById('stat-luck').innerText = RNG.getLuck().toFixed(1) + "x";
        
        // Lucky Counter
        const prog = state.luckyProgress;
        const max = CONFIG.luckyThreshold;
        const lc = document.getElementById('lucky-counter');
        const btn = document.getElementById('roll-btn');
        
        if(prog >= max) {
            lc.innerText = "LUCKY ROLL READY";
            lc.classList.add('ready');
            btn.classList.add('lucky');
        } else {
            lc.innerText = `Lucky Roll: ${prog}/${max}`;
            lc.classList.remove('ready');
            btn.classList.remove('lucky');
        }
    },
    updateInventory: () => {
        // Only render if visible to save performance
        const cont = document.querySelector('#tab-inventory .content-scroll');
        if(cont.parentElement.style.display === 'none') return;
        
        cont.innerHTML = "";
        const keys = Object.keys(state.inventory).filter(k => state.inventory[k] > 0);
        keys.map(k => AURAS.find(a => a.id === k)).sort((a,b)=>b.rarity-a.rarity).forEach(a => {
             const d = document.createElement('div');
             d.className='inv-item'; d.style.borderLeftColor=a.color;
             d.innerHTML = `<span style="color:${a.color};font-weight:bold">${a.name}</span><span class="inv-count">x${state.inventory[a.id]}</span>`;
             d.onmouseenter = () => Tooltip.show(a.name, [{label:"Tier",val:CONFIG.rarityTiers[a.tier].name}], a.color, `${a.coins} Coins`);
             d.onmouseleave = Tooltip.hide;
             cont.appendChild(d);
        });
    },
    renderStaticTabs: () => {
        const shop = document.querySelector('#tab-shop .content-scroll');
        shop.innerHTML = "";
        SHOP_ITEMS.forEach(i => {
            const c=document.createElement('div'); c.className='card';
            c.innerHTML=`<h4>${i.name}</h4><p>${i.desc}</p><button onclick="Actions.buyShop('${i.id}')">${i.cost}</button>`;
            shop.appendChild(c);
        });

        const craft = document.querySelector('#tab-crafting .content-scroll');
        craft.innerHTML = "";
        RECIPES.forEach(r => {
             const c=document.createElement('div'); c.className='card';
             c.innerHTML=`<h4>${r.desc.split('->')[1] || 'Craft'}</h4><p>${r.desc}</p><button onclick="Actions.craft('${r.id}')">Craft</button>`;
             craft.appendChild(c);
        });
    },
    animateRoll: (a, lucky) => {
        const disp = document.getElementById('aura-display');
        disp.classList.remove('show');
        setTimeout(() => {
            document.getElementById('aura-name').innerText = a.name;
            document.getElementById('aura-name').style.color = a.color;
            document.getElementById('aura-name').style.textShadow = `0 0 30px ${a.color}`;
            document.getElementById('aura-rarity').innerText = `1 in ${a.rarity.toLocaleString()}`;
            disp.classList.add('show');
            if(lucky) {
                 document.body.style.boxShadow = `inset 0 0 100px ${a.color}`;
                 setTimeout(()=>document.body.style.boxShadow='none', 800);
            } else if(a.tier >= 4) {
                 document.body.style.boxShadow = `inset 0 0 50px ${a.color}`;
                 setTimeout(()=>document.body.style.boxShadow='none', 400);
            }
        }, 50);
    },
    renderBuffs: () => {
        const b = document.getElementById('active-buffs');
        const now = Date.now();
        b.innerHTML = session.activeBuffs.map(buff => `<div class="buff">${buff.name}: ${Math.ceil((buff.expireTime-now)/1000)}s</div>`).join('');
    },
    toast: (msg, type='info') => {
        const t=document.createElement('div'); t.className='toast'; t.innerText=msg;
        if(type==='error') t.style.borderLeftColor=CONFIG.rarityTiers[5].color; 
        else if(type==='success') t.style.borderLeftColor=CONFIG.rarityTiers[7].color; 
        document.getElementById('toast-container').appendChild(t);
        setTimeout(()=>t.remove(), 3000);
    }
};

const GameLoop = {
    start: () => requestAnimationFrame(GameLoop.tick),
    tick: () => {
        const now = Date.now();
        // Auto Roll Check
        if (state.tree['auto'] && state.autoEnabled && now - session.lastRollTime >= session.currentCooldown) {
            Actions.roll();
        }
        
        // Cooldown Bar
        const prog = Math.min(1, (now - session.lastRollTime) / session.currentCooldown);
        const bar = document.getElementById('cooldown-bar');
        bar.style.width = (prog * 100) + '%';
        bar.style.opacity = prog >= 1 ? 0.5 : 1;

        // Buffs Expiry
        if(session.activeBuffs.length) {
            session.activeBuffs = session.activeBuffs.filter(b => b.expireTime > now);
            UI.renderBuffs();
        }
        requestAnimationFrame(GameLoop.tick);
    }
};

function switchTab(id) {
    document.querySelectorAll('.tab-content').forEach(e=>e.classList.remove('active'));
    document.querySelectorAll('.tab-btn').forEach(e=>e.classList.remove('active'));
    document.getElementById(`tab-${id}`).classList.add('active');
    
    // Find index for button highlight
    const idx = ['inventory','tree','shop','crafting'].indexOf(id);
    if(idx > -1) document.querySelectorAll('.tab-btn')[idx].classList.add('active');
    
    if(id==='inventory') UI.updateInventory();
}

window.onload = UI.init;
</script>
</body>
</html>
