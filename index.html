<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kriss's RNG Game v1.6</title>
    <style>
        :root {
            --bg: #0b0b0f;
            --panel: #14141b;
            --panel-border: #2a2a35;
            --accent: #6c5ce7;
            --accent-glow: rgba(108, 92, 231, 0.5);
            --gold: #fdcb6e;
            --gold-glow: rgba(253, 203, 110, 0.6);
            --text-main: #ffffff;
            --text-muted: #a0a0b0;
            --success: #00b894;
            --success-glow: rgba(0, 184, 148, 0.5);
            --danger: #d63031;
            --danger-glow: rgba(214, 48, 49, 0.5);
            --font: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            --bounce: cubic-bezier(0.34, 1.56, 0.64, 1);
        }

        * { box-sizing: border-box; user-select: none; }
        
        body {
            margin: 0; background-color: var(--bg); color: var(--text-main);
            font-family: var(--font); height: 100vh; overflow: hidden;
            display: flex; flex-direction: column;
        }

        /* --- Header --- */
        header {
            height: 60px; background: var(--panel); border-bottom: 1px solid var(--panel-border);
            padding: 0 20px; display: flex; align-items: center; justify-content: space-between;
            z-index: 20; box-shadow: 0 4px 10px rgba(0,0,0,0.3); flex-shrink: 0;
        }
        .stat-group { display: flex; gap: 25px; }
        .stat { display: flex; flex-direction: column; }
        .stat label { font-size: 0.7rem; color: var(--text-muted); text-transform: uppercase; letter-spacing: 1px; }
        .stat value { font-size: 1.1rem; font-weight: bold; font-variant-numeric: tabular-nums; }
        .currency { color: var(--gold); text-shadow: 0 0 10px rgba(253, 203, 110, 0.2); }

        /* --- Main Stage --- */
        main {
            flex: 1; display: flex; flex-direction: column; align-items: center; justify-content: center;
            position: relative; z-index: 10;
        }

        #aura-display {
            text-align: center; margin-bottom: 30px; opacity: 0;
            transform: scale(0.8); transition: transform 0.4s var(--bounce), opacity 0.3s;
            cursor: help;
        }
        #aura-display.show { opacity: 1; transform: scale(1); }
        #aura-name {
            font-size: 3rem; font-weight: 800; text-transform: uppercase;
            margin: 0; text-shadow: 0 0 30px currentColor;
        }
        #aura-rarity { font-size: 1rem; margin-top: 5px; color: var(--text-muted); }

        /* --- Roll Button --- */
        #roll-container { position: relative; display: flex; flex-direction: column; align-items: center; }
        
        #roll-btn {
            background: var(--accent); color: white; border: none; padding: 20px 60px;
            font-size: 1.5rem; border-radius: 50px; cursor: pointer; font-weight: bold;
            box-shadow: 0 10px 30px var(--accent-glow);
            transition: all 0.3s var(--bounce); z-index: 5;
        }
        #roll-btn:active { transform: scale(0.95); }
        #roll-btn:disabled { background: #333; box-shadow: none; cursor: not-allowed; opacity: 0.7; }
        
        #roll-btn.lucky {
            background: var(--gold); color: #2d3436;
            box-shadow: 0 0 40px var(--gold-glow), inset 0 0 15px rgba(255,255,255,0.8);
            animation: pulse-gold 1.5s infinite;
        }
        @keyframes pulse-gold { 0% { transform: scale(1); } 50% { transform: scale(1.05); } 100% { transform: scale(1); } }

        #lucky-counter {
            margin-top: 15px; font-size: 0.85rem; font-weight: bold; color: var(--text-muted);
            background: rgba(0,0,0,0.3); padding: 5px 12px; border-radius: 20px;
            transition: all 0.3s; border: 1px solid transparent;
        }
        #lucky-counter.ready {
            color: var(--gold); border-color: var(--gold); background: rgba(253, 203, 110, 0.1);
            text-shadow: 0 0 10px var(--gold-glow);
        }

        /* --- Draggable Panel --- */
        #controls-wrapper {
            background: var(--panel); border-top: 1px solid var(--panel-border);
            display: flex; flex-direction: column; z-index: 30;
            height: 320px; min-height: 200px; max-height: 75vh;
            position: relative; box-shadow: 0 -5px 20px rgba(0,0,0,0.5);
        }

        #resize-handle {
            width: 100%; height: 12px; background: #222; cursor: ns-resize;
            display: flex; justify-content: center; align-items: center;
        }
        #resize-handle::after { content: ''; width: 40px; height: 4px; background: #444; border-radius: 2px; }

        #cooldown-container { width: 100%; height: 4px; background: #111; position: relative; }
        #cooldown-bar {
            position: absolute; top: 0; bottom: 0; left: 50%; width: 0;
            background: var(--text-main); transform: translateX(-50%);
            box-shadow: 0 0 10px white; will-change: width;
        }

        .tabs { display: flex; background: #1a1a20; border-bottom: 1px solid var(--panel-border); align-items: center; }
        .tab-btn {
            flex: 1; padding: 12px; background: none; border: none; color: var(--text-muted);
            cursor: pointer; font-weight: 600; font-size: 0.85rem; border-bottom: 2px solid transparent;
        }
        .tab-btn:hover { color: var(--text-main); background: rgba(255,255,255,0.03); }
        .tab-btn.active { color: var(--accent); border-bottom-color: var(--accent); background: rgba(108, 92, 231, 0.05); }

        #auto-wrapper {
            padding: 0 15px; display: flex; align-items: center; gap: 10px; border-left: 1px solid var(--panel-border); height: 100%;
        }
        .switch { position: relative; display: inline-block; width: 34px; height: 18px; }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider {
            position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0;
            background-color: #333; transition: .4s; border-radius: 34px;
        }
        .slider:before {
            position: absolute; content: ""; height: 12px; width: 12px; left: 3px; bottom: 3px;
            background-color: white; transition: .4s; border-radius: 50%;
        }
        input:checked + .slider { background-color: var(--success); }
        input:checked + .slider:before { transform: translateX(16px); }

        /* --- Content & Items --- */
        .tab-content { flex: 1; position: relative; overflow: hidden; display: none; background: var(--bg); }
        .tab-content.active { display: block; }
        .content-scroll { 
            padding: 15px; overflow-y: auto; height: 100%; 
            display: grid; gap: 10px; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            align-content: start;
        }

        /* Settings Tab Styles */
        #tab-settings .content-scroll { display: flex; flex-direction: column; gap: 20px; }
        .settings-section {
            background: rgba(255,255,255,0.03); border: 1px solid var(--panel-border);
            padding: 15px; border-radius: 8px;
        }
        .settings-section h3 { margin: 0 0 10px 0; font-size: 1rem; color: var(--text-muted); border-bottom: 1px solid #333; padding-bottom: 5px; }
        .btn-group { display: flex; gap: 10px; margin-top: 10px; }
        .action-btn {
            flex: 1; padding: 10px; border: 1px solid #444; background: #222; color: white;
            border-radius: 4px; cursor: pointer; font-weight: bold; transition: all 0.2s;
        }
        .action-btn:hover { background: #333; border-color: #666; }
        .action-btn.danger { border-color: #d63031; color: #d63031; background: rgba(214, 48, 49, 0.05); }
        .action-btn.danger:hover { background: #d63031; color: white; }
        .warning-text { color: var(--danger); font-size: 0.8rem; margin-top: 5px; display: none; }
        .warning-text.visible { display: block; animation: shake 0.3s; }
        @keyframes shake { 0% { transform: translateX(0); } 25% { transform: translateX(-5px); } 75% { transform: translateX(5px); } 100% { transform: translateX(0); } }

        /* General Card & Item Styles */
        .card {
            background: rgba(255,255,255,0.03); border: 1px solid rgba(255,255,255,0.05);
            padding: 10px; border-radius: 6px; display: flex; flex-direction: column;
            justify-content: space-between; transition: transform 0.2s var(--bounce);
        }
        .card:hover { transform: translateY(-2px); border-color: rgba(255,255,255,0.1); }
        .card h4 { margin: 0 0 4px 0; color: var(--accent); font-size: 0.9rem; }
        .card p { font-size: 0.75rem; color: var(--text-muted); margin: 0 0 8px 0; line-height: 1.3; }
        .card button {
            background: #333; color: white; border: none; padding: 6px; border-radius: 4px;
            cursor: pointer; width: 100%; font-size: 0.8rem; font-weight: 600; margin-top: auto;
        }

        /* Inventory Item */
        .inv-item {
            display: flex; flex-direction: column; gap: 5px;
            background: rgba(0,0,0,0.2); padding: 8px 10px; border-radius: 4px;
            border-left: 3px solid transparent; cursor: help;
        }
        .inv-head { display: flex; justify-content: space-between; align-items: center; width: 100%; }
        .inv-name { font-weight: bold; font-size: 0.85rem; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; max-width: 100px; }
        .inv-count { color: var(--text-muted); font-size: 0.8rem; }
        .sell-btn {
            background: rgba(214, 48, 49, 0.1); border: 1px solid #d63031; color: #d63031;
            font-size: 0.7rem; padding: 2px 0; cursor: pointer; border-radius: 3px; width: 100%;
        }
        .sell-btn:hover { background: #d63031; color: white; }

        /* Tree Styles */
        #tree-viewport {
            width: 100%; height: 100%; overflow: hidden; position: relative;
            background-image: radial-gradient(#2a2a35 1px, transparent 1px);
            background-size: 20px 20px; cursor: grab;
        }
        #tree-viewport:active { cursor: grabbing; }
        #tree-container { transform-origin: 0 0; position: absolute; top: 0; left: 0; }
        .tree-node {
            position: absolute; width: 44px; height: 44px;
            background: #1a1a1a; border: 2px solid #444; border-radius: 50%;
            display: flex; align-items: center; justify-content: center;
            color: #666; font-weight: bold; cursor: pointer;
            transition: all 0.3s var(--bounce); z-index: 2;
        }
        .tree-node.unlocked { border-color: var(--success); color: var(--success); background: #0f2b23; box-shadow: 0 0 15px var(--success-glow); }
        .tree-node.available { border-color: var(--accent); color: #fff; background: var(--panel); box-shadow: 0 0 10px var(--accent-glow); }
        .tree-node.expansion { width: 54px; height: 54px; border-radius: 8px; border-width: 3px; border-color: #e17055; color: #e17055; }
        svg.connections { position: absolute; top: 0; left: 0; width: 6000px; height: 6000px; z-index: 1; pointer-events: none; }
        path.conn-line { fill: none; stroke: #333; stroke-width: 3; }
        path.conn-line.owned { stroke: var(--success); opacity: 0.8; }
        path.conn-line.available { stroke: var(--accent); stroke-dasharray: 6; opacity: 0.5; }
        #tree-controls { position: absolute; top: 15px; right: 15px; display: flex; gap: 5px; z-index: 10; }
        .zoom-btn { width: 32px; height: 32px; background: rgba(0,0,0,0.8); border: 1px solid #444; color: white; border-radius: 4px; cursor: pointer; }

        /* Toast & Buffs */
        #active-buffs { position: absolute; top: 20px; left: 20px; display: flex; flex-direction: column; gap: 5px; z-index: 5; }
        .buff { font-size: 0.75rem; color: #000; font-weight: bold; background: var(--success); padding: 4px 8px; border-radius: 4px; box-shadow: 0 2px 10px rgba(0,0,0,0.3); }
        #toast-container { position: fixed; bottom: 350px; right: 20px; display: flex; flex-direction: column; gap: 10px; pointer-events: none; z-index: 100; }
        .toast {
            background: rgba(20, 20, 30, 0.95); border-left: 4px solid var(--accent); color: white;
            padding: 10px 20px; border-radius: 4px; animation: slideIn 0.3s var(--bounce);
        }
        @keyframes slideIn { from { transform: translateX(100%); opacity: 0; } to { transform: translateX(0); opacity: 1; } }
        
        #tooltip {
            position: fixed; pointer-events: none; z-index: 9999;
            background: rgba(10, 10, 15, 0.98); border: 1px solid var(--panel-border);
            border-radius: 6px; padding: 12px; min-width: 220px; opacity: 0; transition: opacity 0.1s;
        }
        #tooltip.visible { opacity: 1; }
        #tooltip h3 { margin: 0 0 6px 0; font-size: 1rem; color: white; border-bottom: 1px solid #333; padding-bottom: 6px; }
        #tooltip .row { display: flex; justify-content: space-between; font-size: 0.8rem; color: var(--text-muted); margin-bottom: 3px; }
        #tooltip .val { color: white; font-weight: bold; }
    </style>
</head>
<body>

    <header>
        <div class="stat-group">
            <div class="stat">
                <label>Rolls</label>
                <value id="stat-rolls">0</value>
            </div>
            <div class="stat">
                <label>Coins</label>
                <value id="stat-coins" class="currency">0</value>
            </div>
        </div>
        <div class="stat-group">
            <div class="stat" style="text-align: right;">
                <label>Luck</label>
                <value id="stat-luck">1.0x</value>
            </div>
            <div class="stat" style="text-align: right; color:#888; font-size:0.8rem; align-self:center;">v1.6</div>
        </div>
    </header>

    <main id="main-stage">
        <div id="active-buffs"></div>
        <div id="aura-display" onmouseenter="Tooltip.showCurrentAura()" onmouseleave="Tooltip.hide()">
            <h1 id="aura-name">Kriss's RNG Game</h1>
            <div id="aura-rarity">Begin the Cycle</div>
        </div>
        <div id="roll-container">
            <button id="roll-btn">ROLL</button>
            <div id="lucky-counter">Lucky Roll: 0/10</div>
        </div>
    </main>

    <div id="controls-wrapper">
        <div id="resize-handle"></div>
        <div id="cooldown-container"><div id="cooldown-bar"></div></div>

        <div class="tabs">
            <button class="tab-btn active" onclick="switchTab('inventory')">Auras</button>
            <button class="tab-btn" onclick="switchTab('tree')">Tree</button>
            <button class="tab-btn" onclick="switchTab('shop')">Shop</button>
            <button class="tab-btn" onclick="switchTab('crafting')">Crafting</button>
            <button class="tab-btn" onclick="switchTab('settings')">‚öôÔ∏è</button>
            
            <div id="auto-wrapper" title="Unlock Auto-Roll in Tree first">
                <span style="font-size:0.75rem; font-weight:bold; color:#888;">AUTO</span>
                <label class="switch">
                    <input type="checkbox" id="auto-check" disabled onchange="Actions.toggleAuto()">
                    <span class="slider"></span>
                </label>
            </div>
        </div>

        <div id="tab-inventory" class="tab-content active"><div class="content-scroll"></div></div>
        
        <div id="tab-tree" class="tab-content" style="background:#0a0a0f;">
            <div id="tree-viewport">
                <div id="tree-controls">
                    <button class="zoom-btn" onclick="Tree.zoom(0.1)">+</button>
                    <button class="zoom-btn" onclick="Tree.zoom(-0.1)">-</button>
                    <button class="zoom-btn" onclick="Tree.reset()">R</button>
                </div>
                <div id="tree-container">
                    <svg class="connections" id="tree-lines"></svg>
                </div>
            </div>
        </div>

        <div id="tab-shop" class="tab-content"><div class="content-scroll"></div></div>
        <div id="tab-crafting" class="tab-content"><div class="content-scroll"></div></div>
        
        <div id="tab-settings" class="tab-content">
            <div class="content-scroll">
                <div class="settings-section">
                    <h3>Save Management</h3>
                    <p>Back up your save to your clipboard or import a code. (Auto-saves every 30s)</p>
                    <div class="btn-group">
                        <button class="action-btn" onclick="SaveSystem.export()">Export Save</button>
                        <button class="action-btn" onclick="SaveSystem.import()">Import Save</button>
                    </div>
                </div>

                <div class="settings-section" style="border-color: rgba(214, 48, 49, 0.3);">
                    <h3 style="color: #d63031;">Danger Zone</h3>
                    <p>Permanently delete all progress. This cannot be undone.</p>
                    <div class="btn-group">
                        <button class="action-btn danger" id="reset-btn" onclick="SaveSystem.confirmReset()">Reset Everything</button>
                    </div>
                    <div id="reset-warning" class="warning-text">‚ö†Ô∏è This action is irreversible! Click again to confirm.</div>
                </div>
            </div>
        </div>
    </div>

    <div id="tooltip"></div>
    <div id="toast-container"></div>

<script>
/**
 * Kriss's RNG Game v1.6: PERSISTENCE UPDATE
 * - Implementation of Save/Load (Base64)
 * - Full Reset with Double Confirmation
 * - State architecture refactor
 */

const CONFIG = {
    auraCount: 125,
    baseCooldown: 2500,
    luckyThreshold: 10,
    rarityTiers: [
        { name: "Common",     chance: 2,       color: "#b2bec3", coinMult: 1 },
        { name: "Uncommon",   chance: 5,       color: "#81ecec", coinMult: 3 },
        { name: "Rare",       chance: 16,      color: "#0984e3", coinMult: 10 },
        { name: "Epic",       chance: 64,      color: "#6c5ce7", coinMult: 40 },
        { name: "Legendary",  chance: 256,     color: "#fdcb6e", coinMult: 150 },
        { name: "Mythical",   chance: 1024,    color: "#d63031", coinMult: 800 },
        { name: "Divine",     chance: 4096,    color: "#e84393", coinMult: 4000 },
        { name: "Celestial",  chance: 16384,   color: "#00b894", coinMult: 20000 },
        { name: "Godly",      chance: 65536,   color: "#a29bfe", coinMult: 80000 },
        { name: "Zenith",     chance: 1000000, color: "#ffffff", coinMult: 500000 }
    ]
};

const WORDS = {
    prefixes: ["Faded", "Pale", "Bright", "Gilded", "Abyssal", "Solar", "Lunar", "Void", "Star", "Time", "Blood", "Azure", "Crimson", "Neon", "Cyber", "Glitch", "Holy", "Cursed", "Omega", "Alpha", "Eternal", "Broken"],
    suffixes: ["Spark", "Dust", "Flame", "Wave", "Mist", "Stone", "Wind", "Storm", "Pulse", "Shard", "Soul", "Gate", "Matter", "Energy", "Construct", "Dream", "Nightmare", "Singularity", "Essence", "Light", "Darkness"]
};

// --- DATA ---
const AURAS = [];
function generateAuras() {
    for (let i = 0; i < CONFIG.auraCount; i++) {
        let tierIdx = 0;
        if(i > 25) tierIdx = 1; if(i > 50) tierIdx = 2; if(i > 70) tierIdx = 3;
        if(i > 85) tierIdx = 4; if(i > 95) tierIdx = 5; if(i > 100) tierIdx = 6;
        if(i > 105) tierIdx = 7; if(i > 110) tierIdx = 8; if(i === 124) tierIdx = 9;
        const tier = CONFIG.rarityTiers[tierIdx];
        const p = WORDS.prefixes[Math.floor(Math.random() * WORDS.prefixes.length)];
        const s = WORDS.suffixes[Math.floor(Math.random() * WORDS.suffixes.length)];
        AURAS.push({
            id: `aura_${i}`, name: i === 124 ? "SOLIS: GENESIS" : `${p} ${s}`, tier: tierIdx, rarity: Math.floor(tier.chance * (1 + (i % 5) * 0.15)),
            coins: Math.max(1, Math.floor(tier.coinMult * (1 + Math.random()*0.1))), color: tier.color
        });
    }
    AURAS.sort((a, b) => b.rarity - a.rarity);
}
generateAuras();

const G = 90;
const TREE_NODES = [
    { id: 'root', x: 0, y: 0, icon: 'üè†', name: "Awakening", cost: 0, parents: [], type: 'root', desc: "Start" },
    { id: 'l1', x: -1*G, y: 0, icon: 'üçÄ', name: "Luck I", cost: 50, parents: ['root'], type: 'luck', val: 0.1, desc: "+0.1x Luck" },
    { id: 'l2', x: -2*G, y: 0, icon: 'üçÄ', name: "Luck II", cost: 250, parents: ['l1'], type: 'luck', val: 0.2, desc: "+0.2x Luck" },
    { id: 'l3', x: -3*G, y: 0, icon: 'üçÄ', name: "Luck III", cost: 1200, parents: ['l2'], type: 'luck', val: 0.3, desc: "+0.3x Luck" },
    { id: 's1', x: 1*G, y: 0, icon: '‚ö°', name: "Speed I", cost: 100, parents: ['root'], type: 'speed', val: 0.1, desc: "+10% Speed" },
    { id: 's2', x: 2*G, y: 0, icon: '‚ö°', name: "Speed II", cost: 400, parents: ['s1'], type: 'speed', val: 0.15, desc: "+15% Speed" },
    { id: 'auto', x: 2*G, y: 1*G, icon: 'ü§ñ', name: "Auto-Roll", cost: 2500, parents: ['s2'], type: 'unlock_auto', val: 1, desc: "Unlocks Auto Switch" },
    { id: 's3', x: 3*G, y: 0, icon: '‚ö°', name: "Speed III", cost: 1500, parents: ['s2'], type: 'speed', val: 0.2, desc: "+20% Speed" },
    { id: 'c1', x: 0, y: 1*G, icon: 'üí∞', name: "Coins I", cost: 75, parents: ['root'], type: 'coin', val: 0.2, desc: "+20% Coins" },
    { id: 'c2', x: 0, y: 2*G, icon: 'üí∞', name: "Coins II", cost: 350, parents: ['c1'], type: 'coin', val: 0.3, desc: "+30% Coins" },
    { id: 'c3', x: 0, y: 3*G, icon: 'üí∞', name: "Coins III", cost: 1500, parents: ['c2'], type: 'coin', val: 0.4, desc: "+40% Coins" },
    { id: 'c5', x: 0, y: 5*G, icon: 'üíé', name: "Tycoon", cost: 20000, parents: ['c3'], type: 'coin', val: 1.0, desc: "Double Coins" },
    { id: 'exp_void', x: 0, y: -2*G, icon: 'üåå', name: "Void Gate", cost: 4000, parents: ['root'], type: 'expansion', desc: "Unlocks Void Path" },
    { id: 'v_luck', x: -1*G, y: -3*G, icon: 'üßø', name: "Void Luck", cost: 6000, parents: ['exp_void'], type: 'luck', val: 0.5, desc: "+0.5 Luck", reqExp: 'exp_void' },
    { id: 'exp_time', x: 4*G, y: 1*G, icon: '‚è≥', name: "Chronos", cost: 12000, parents: ['s3'], type: 'expansion', desc: "Time Manipulation" },
    { id: 't_haste', x: 5*G, y: 1*G, icon: '‚è©', name: "Temporal Haste", cost: 20000, parents: ['exp_time'], type: 'speed', val: 0.6, desc: "+60% Speed", reqExp: 'exp_time' }
];

const SHOP_ITEMS = [
    { id: 'pot_luck_s', name: "Minor Luck Potion", cost: 100, duration: 30000, type: 'luck', val: 1.5, desc: "1.5x Luck (30s)" },
    { id: 'pot_speed', name: "Haste Vial", cost: 250, duration: 45000, type: 'speed', val: 2.0, desc: "2x Speed (45s)" }
];

const RECIPES = [
    { id: 'r1', output: 'coins', amount: 100, inputTier: 0, count: 10, desc: "10 Common -> 100 Coins" },
    { id: 'r2', output: 'pot_luck_s', inputTier: 1, count: 5, desc: "5 Uncommon -> Minor Luck Pot" }
];

// --- STATE MANAGEMENT ---

const DEFAULT_STATE = {
    rolls: 0,
    coins: 0,
    inventory: {},
    tree: { 'root': true },
    luckyProgress: 0,
    autoEnabled: false,
    activeBuffs: [], // Moved buffs to state for persistence
    savedCooldown: 0
};

let state = JSON.parse(JSON.stringify(DEFAULT_STATE)); // Deep copy default
let session = {
    lastRollTime: 0,
    currentCooldown: CONFIG.baseCooldown,
    currentAura: null,
    tree: { x: window.innerWidth/2, y: window.innerHeight/3, scale: 1, dragging: false, lx: 0, ly: 0 },
    resetStage: 0
};

const RNG = {
    getLuck: () => {
        let mult = 1.0;
        TREE_NODES.forEach(n => { if(state.tree[n.id] && n.type==='luck') mult += n.val; });
        if(state.activeBuffs.length) mult *= Math.max(1, ...state.activeBuffs.filter(b=>b.type==='luck').map(p=>p.val));
        if(state.luckyProgress >= CONFIG.luckyThreshold) mult *= 1.15; // Basic Lucky bonus
        return mult;
    },
    getSpeedMult: () => {
        let mult = 1.0;
        TREE_NODES.forEach(n => { if(state.tree[n.id] && n.type==='speed') mult += n.val; });
        if(state.activeBuffs.length) mult *= Math.max(1, ...state.activeBuffs.filter(b=>b.type==='speed').map(p=>p.val));
        return mult;
    }
};

const SaveSystem = {
    encode: () => {
        // Prepare data: filter expired buffs, save remaining time on cooldown
        const now = Date.now();
        state.activeBuffs = state.activeBuffs.filter(b => b.expireTime > now);
        
        // Calculate remaining cooldown relative to now
        const timeSinceRoll = now - session.lastRollTime;
        state.savedCooldown = (timeSinceRoll < session.currentCooldown) ? (session.currentCooldown - timeSinceRoll) : 0;

        // Create save object with timestamp
        const saveObj = {
            v: "1.6",
            ts: now,
            data: state
        };
        return btoa(JSON.stringify(saveObj));
    },
    saveLocal: () => {
        try {
            localStorage.setItem("solis_save", SaveSystem.encode());
            // Silent save
        } catch(e) { console.error("Auto-save failed", e); }
    },
    loadLocal: () => {
        const str = localStorage.getItem("solis_save");
        if(str) SaveSystem.decode(str);
    },
    export: () => {
        const str = SaveSystem.encode();
        navigator.clipboard.writeText(str).then(() => UI.toast("Save copied to clipboard!", "success"));
    },
    import: () => {
        const str = prompt("Paste your save string here:");
        if(str) {
            if(SaveSystem.decode(str)) UI.toast("Save Loaded Successfully!", "success");
            else UI.toast("Invalid Save String", "error");
        }
    },
    decode: (str) => {
        try {
            const raw = atob(str);
            const obj = JSON.parse(raw);
            if(!obj.data) return false;
            
            state = obj.data;
            
            // Restore Session Logic
            const now = Date.now();
            
            // Fix Buff Timestamps: Buffs were saved with absolute times. 
            // If we load an old save, buffs expire. 
            // If we want buffs to "pause" while offline, we would need to save remaining duration.
            // For this implementation, we assume time passes while offline.
            state.activeBuffs = state.activeBuffs.filter(b => b.expireTime > now);
            
            // Restore Cooldown
            if(state.savedCooldown > 0) {
                session.currentCooldown = state.savedCooldown; // Temporary override
                session.lastRollTime = now; // Treat as if we just rolled so the bar fills up
            } else {
                session.lastRollTime = 0; // Ready to roll
            }

            // Restore Auto Switch
            document.getElementById('auto-check').checked = state.autoEnabled;
            if(state.tree['auto']) document.getElementById('auto-check').disabled = false;

            // UI Updates
            UI.updateStats();
            UI.updateInventory();
            Tree.render();
            UI.renderBuffs();
            return true;
        } catch(e) {
            console.error(e);
            return false;
        }
    },
    confirmReset: () => {
        const btn = document.getElementById('reset-btn');
        const warn = document.getElementById('reset-warning');
        
        if(session.resetStage === 0) {
            session.resetStage = 1;
            btn.innerText = "Are you sure?";
            warn.classList.add('visible');
        } else if (session.resetStage === 1) {
            session.resetStage = 2;
            btn.innerText = "CONFIRM DELETION";
            btn.style.background = "#d63031";
            btn.style.color = "white";
        } else {
            SaveSystem.hardReset();
        }
    },
    hardReset: () => {
        localStorage.removeItem("solis_save");
        state = JSON.parse(JSON.stringify(DEFAULT_STATE));
        session.resetStage = 0;
        
        // UI Reset
        document.getElementById('reset-btn').innerText = "Reset Everything";
        document.getElementById('reset-btn').style.background = "";
        document.getElementById('reset-btn').style.color = "";
        document.getElementById('reset-warning').classList.remove('visible');
        document.getElementById('auto-check').checked = false;
        document.getElementById('auto-check').disabled = true;

        UI.toast("Game Reset Complete", "success");
        UI.updateStats();
        UI.updateInventory();
        Tree.render();
        UI.renderBuffs();
        session.lastRollTime = 0; // Ready immediately
    }
};

const Actions = {
    roll: () => {
        const now = Date.now();
        if (now - session.lastRollTime < session.currentCooldown) return;
        session.lastRollTime = now;
        
        const isLucky = state.luckyProgress >= CONFIG.luckyThreshold;
        const luck = RNG.getLuck();
        let result = AURAS[AURAS.length-1];
        
        for (const aura of AURAS) {
            if (Math.random() * (aura.rarity / luck) < 1) {
                result = aura;
                break;
            }
        }
        session.currentAura = result;
        let coinMult = 1.0;
        TREE_NODES.forEach(n => { if(state.tree[n.id] && n.type==='coin') coinMult += n.val; });
        state.coins += Math.floor(result.coins * coinMult);
        state.rolls++;
        state.inventory[result.id] = (state.inventory[result.id] || 0) + 1;

        if(isLucky) { state.luckyProgress = 0; UI.toast("Lucky Roll Used!", "success"); } 
        else { state.luckyProgress++; }

        UI.animateRoll(result, isLucky);
        UI.updateStats();
        UI.updateInventory();

        session.currentCooldown = CONFIG.baseCooldown / RNG.getSpeedMult();
        const btn = document.getElementById('roll-btn');
        btn.disabled = true;
        setTimeout(() => { if(!state.autoEnabled) btn.disabled = false; }, session.currentCooldown);
        SaveSystem.saveLocal(); // Auto save on roll
    },

    toggleAuto: () => {
        if (!state.tree['auto']) return;
        state.autoEnabled = document.getElementById('auto-check').checked;
        UI.toast(state.autoEnabled ? "Auto-Roll Active" : "Auto-Roll Paused", state.autoEnabled ? "success" : "info");
    },

    buyNode: (id) => {
        if(state.tree[id]) return;
        const node = TREE_NODES.find(n => n.id === id);
        const parentsMet = node.parents.every(p => state.tree[p]);
        if(!parentsMet) { UI.toast("Locked path!", "error"); return; }
        if(state.coins < node.cost) { UI.toast("Not enough coins!", "error"); return; }

        state.coins -= node.cost;
        state.tree[id] = true;
        if(node.type === 'unlock_auto') { document.getElementById('auto-check').disabled = false; UI.toast("Auto-Roll Unlocked!", "success"); }
        else UI.toast(`${node.name} Acquired!`, "success");

        UI.updateStats();
        Tree.render();
        SaveSystem.saveLocal();
    },

    buyShop: (id) => {
        const item = SHOP_ITEMS.find(i => i.id === id);
        if(state.coins >= item.cost) {
            state.coins -= item.cost;
            const existing = state.activeBuffs.find(b => b.name === item.name);
            if(existing) { existing.expireTime += item.duration; UI.toast(`${item.name} Extended!`); } 
            else { state.activeBuffs.push({ type: item.type, val: item.val, name: item.name, expireTime: Date.now() + item.duration }); UI.toast(`${item.name} Active!`, "success"); }
            UI.updateStats(); UI.renderBuffs();
        } else { UI.toast("Need more coins", "error"); }
    },
    
    craft: (rid) => {
        const rcp = RECIPES.find(r => r.id === rid);
        const invAuras = AURAS.filter(a => a.tier === rcp.inputTier);
        let needed = rcp.count;
        let consumed = {};

        for(let a of invAuras) {
            let has = state.inventory[a.id] || 0;
            if(has > 0) {
                let take = Math.min(has, needed);
                consumed[a.id] = take;
                needed -= take;
                if(needed <= 0) break;
            }
        }
        if(needed > 0) { UI.toast(`Need ${rcp.count} Tier ${rcp.inputTier} Auras`, "error"); return; }
        for(let id in consumed) state.inventory[id] -= consumed[id];
        
        if(rcp.output === 'coins') { state.coins += rcp.amount; UI.toast(`+${rcp.amount} Coins`); } 
        else {
            const item = SHOP_ITEMS.find(i => i.id === rcp.output);
            if(item) {
                const existing = state.activeBuffs.find(b => b.name === item.name);
                if(existing) existing.expireTime += item.duration;
                else state.activeBuffs.push({ type: item.type, val: item.val, name: item.name, expireTime: Date.now() + item.duration });
                UI.toast("Potion Brewed!", "success");
            }
        }
        UI.updateStats(); UI.updateInventory();
    },

    sell: (id) => {
        if(!state.inventory[id] || state.inventory[id] <= 0) return;
        const aura = AURAS.find(a => a.id === id);
        const val = Math.floor(aura.coins * 0.1);
        state.inventory[id]--;
        state.coins += val;
        UI.toast(`Sold for ${val} coins`);
        UI.updateStats(); UI.updateInventory();
        SaveSystem.saveLocal();
    }
};

const Tree = {
    init: () => {
        const vp = document.getElementById('tree-viewport');
        vp.addEventListener('mousedown', e => {
            if(e.target.closest('.tree-node')) return;
            session.tree.dragging = true; session.tree.lx = e.clientX; session.tree.ly = e.clientY;
        });
        window.addEventListener('mouseup', () => session.tree.dragging = false);
        window.addEventListener('mousemove', e => {
            if(!session.tree.dragging) return;
            session.tree.x += e.clientX - session.tree.lx; session.tree.y += e.clientY - session.tree.ly;
            session.tree.lx = e.clientX; session.tree.ly = e.clientY;
            Tree.apply();
        });
        vp.addEventListener('wheel', e => { e.preventDefault(); Tree.zoom(e.deltaY > 0 ? -0.1 : 0.1); });
        Tree.render(); Tree.apply();
    },
    zoom: (d) => { session.tree.scale = Math.max(0.3, Math.min(2.0, session.tree.scale + d)); Tree.apply(); },
    reset: () => { session.tree = { x: window.innerWidth/2, y: window.innerHeight/3, scale: 1, dragging: false, lx: 0, ly: 0 }; Tree.apply(); },
    apply: () => { document.getElementById('tree-container').style.transform = `translate(${session.tree.x}px, ${session.tree.y}px) scale(${session.tree.scale})`; },
    render: () => {
        const svg = document.getElementById('tree-lines'); const cont = document.getElementById('tree-container');
        Array.from(cont.querySelectorAll('.tree-node')).forEach(e => e.remove()); svg.innerHTML = "";
        const visibleNodes = TREE_NODES.filter(n => !n.reqExp || state.tree[n.reqExp]);
        visibleNodes.forEach(node => {
            node.parents.forEach(pid => {
                const p = TREE_NODES.find(n => n.id === pid);
                if(!p || !visibleNodes.includes(p)) return;
                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                const off1 = p.type === 'expansion' ? 27 : 22; const off2 = node.type === 'expansion' ? 27 : 22;
                path.setAttribute('d', `M${p.x + off1} ${p.y + off1} L${node.x + off2} ${node.y + off2}`);
                let lineClass = 'conn-line';
                if(state.tree[node.id]) lineClass += ' owned';
                else if(state.tree[p.id]) { if(state.coins >= node.cost) lineClass += ' available'; else lineClass += ' blocked'; }
                path.setAttribute('class', lineClass);
                svg.appendChild(path);
            });
            const el = document.createElement('div');
            const owned = state.tree[node.id]; const parentsMet = node.parents.every(pid => state.tree[pid]);
            let cls = 'tree-node'; if(node.type === 'expansion') cls += ' expansion';
            if(owned) cls += ' unlocked'; else if(parentsMet) cls += ' available';
            el.className = cls; el.style.left = node.x + 'px'; el.style.top = node.y + 'px'; el.innerHTML = `<i>${node.icon}</i>`;
            el.onclick = (e) => { e.stopPropagation(); Actions.buyNode(node.id); };
            el.onmouseenter = () => {
                const color = owned ? '#00b894' : (parentsMet ? (state.coins>=node.cost ? '#fdcb6e' : '#d63031') : '#555');
                Tooltip.show(node.name, [{label:'Effect',val:node.desc}], color, owned?"Owned":node.cost, !parentsMet);
            };
            el.onmouseleave = Tooltip.hide;
            cont.appendChild(el);
        });
    }
};

const Tooltip = {
    el: document.getElementById('tooltip'),
    show: (title, rows, color, cost=null, locked=false) => {
        Tooltip.el.style.borderColor = color;
        let html = `<h3 style="color:${color}">${title}</h3>`;
        rows.forEach(r => html += `<div class="row"><span>${r.label}</span><span class="val">${r.val}</span></div>`);
        if(cost) html += `<div class="cost ${locked?'locked':''}">${cost} Coins</div>`;
        Tooltip.el.innerHTML = html; Tooltip.el.classList.add('visible');
    },
    hide: () => Tooltip.el.classList.remove('visible'),
    move: (e) => {
        if(!Tooltip.el.classList.contains('visible')) return;
        Tooltip.el.style.left = Math.min(window.innerWidth - 240, e.clientX + 15) + 'px';
        Tooltip.el.style.top = Math.min(window.innerHeight - 150, e.clientY + 15) + 'px';
    },
    showCurrentAura: () => {
        if(!session.currentAura) return;
        const a = session.currentAura;
        Tooltip.show(a.name, [{label:"Chance", val:`1 in ${a.rarity.toLocaleString()}`},{label:"Value", val:a.coins}], a.color);
    }
};

const UI = {
    init: () => {
        Resizer.init(); Tree.init(); UI.renderStaticTabs();
        document.getElementById('roll-btn').onclick = Actions.roll;
        document.addEventListener('mousemove', Tooltip.move);
        SaveSystem.loadLocal(); // Load on start
        GameLoop.start();
        setInterval(SaveSystem.saveLocal, 30000); // Auto save interval
    },
    updateStats: () => {
        document.getElementById('stat-rolls').innerText = state.rolls.toLocaleString();
        document.getElementById('stat-coins').innerText = state.coins.toLocaleString();
        document.getElementById('stat-luck').innerText = RNG.getLuck().toFixed(1) + "x";
        const prog = state.luckyProgress;
        const lc = document.getElementById('lucky-counter');
        const btn = document.getElementById('roll-btn');
        if(prog >= CONFIG.luckyThreshold) { lc.innerText = "LUCKY ROLL READY"; lc.classList.add('ready'); btn.classList.add('lucky'); } 
        else { lc.innerText = `Lucky Roll: ${prog}/${CONFIG.luckyThreshold}`; lc.classList.remove('ready'); btn.classList.remove('lucky'); }
    },
    updateInventory: () => {
        const cont = document.querySelector('#tab-inventory .content-scroll');
        if(cont.parentElement.style.display === 'none') return;
        cont.innerHTML = "";
        const keys = Object.keys(state.inventory).filter(k => state.inventory[k] > 0);
        keys.map(k => AURAS.find(a => a.id === k)).sort((a,b)=>b.rarity-a.rarity).forEach(a => {
             const d = document.createElement('div');
             d.className='inv-item'; d.style.borderLeftColor=a.color;
             d.innerHTML = `
                <div class="inv-head"><span class="inv-name" style="color:${a.color}">${a.name}</span><span class="inv-count">x${state.inventory[a.id]}</span></div>
                <button class="sell-btn" onclick="Actions.sell('${a.id}')">SELL (${Math.floor(a.coins*0.1)})</button>
             `;
             d.onmouseenter = () => Tooltip.show(a.name, [{label:"Rarity",val:`1 in ${a.rarity.toLocaleString()}`}], a.color);
             d.onmouseleave = Tooltip.hide;
             cont.appendChild(d);
        });
    },
    renderStaticTabs: () => {
        const shop = document.querySelector('#tab-shop .content-scroll'); shop.innerHTML = "";
        SHOP_ITEMS.forEach(i => {
            const c=document.createElement('div'); c.className='card';
            c.innerHTML=`<h4>${i.name}</h4><p>${i.desc}</p><button onclick="Actions.buyShop('${i.id}')">${i.cost}</button>`;
            shop.appendChild(c);
        });
        const craft = document.querySelector('#tab-crafting .content-scroll'); craft.innerHTML = "";
        RECIPES.forEach(r => {
             const c=document.createElement('div'); c.className='card';
             c.innerHTML=`<h4>${r.desc.split('->')[1] || 'Craft'}</h4><p>${r.desc}</p><button onclick="Actions.craft('${r.id}')">Craft</button>`;
             craft.appendChild(c);
        });
    },
    animateRoll: (a, lucky) => {
        const disp = document.getElementById('aura-display'); disp.classList.remove('show');
        setTimeout(() => {
            document.getElementById('aura-name').innerText = a.name;
            document.getElementById('aura-name').style.color = a.color;
            document.getElementById('aura-name').style.textShadow = `0 0 30px ${a.color}`;
            document.getElementById('aura-rarity').innerText = `1 in ${a.rarity.toLocaleString()}`;
            disp.classList.add('show');
            if(lucky) { document.body.style.boxShadow = `inset 0 0 100px ${a.color}`; setTimeout(()=>document.body.style.boxShadow='none', 800); }
        }, 50);
    },
    renderBuffs: () => {
        const b = document.getElementById('active-buffs');
        const now = Date.now();
        b.innerHTML = state.activeBuffs.map(buff => `<div class="buff">${buff.name}: ${Math.ceil((buff.expireTime-now)/1000)}s</div>`).join('');
    },
    toast: (msg, type='info') => {
        const t=document.createElement('div'); t.className='toast'; t.innerText=msg;
        if(type==='error') t.style.borderLeftColor=CONFIG.rarityTiers[5].color; 
        else if(type==='success') t.style.borderLeftColor=CONFIG.rarityTiers[7].color; 
        document.getElementById('toast-container').appendChild(t); setTimeout(()=>t.remove(), 3000);
    }
};

const Resizer = { init: () => {
    const h = document.getElementById('resize-handle'); const p = document.getElementById('controls-wrapper'); let isResizing = false;
    h.addEventListener('mousedown', (e) => { isResizing = true; e.preventDefault(); });
    window.addEventListener('mouseup', () => isResizing = false);
    window.addEventListener('mousemove', (e) => { if(!isResizing) return; p.style.height = Math.max(200, Math.min(window.innerHeight*0.75, window.innerHeight - e.clientY)) + 'px'; });
}};

const GameLoop = {
    start: () => requestAnimationFrame(GameLoop.tick),
    tick: () => {
        const now = Date.now();
        if (state.tree['auto'] && state.autoEnabled && now - session.lastRollTime >= session.currentCooldown) Actions.roll();
        const prog = Math.min(1, (now - session.lastRollTime) / session.currentCooldown);
        document.getElementById('cooldown-bar').style.width = (prog * 100) + '%';
        if(state.activeBuffs.length) { state.activeBuffs = state.activeBuffs.filter(b => b.expireTime > now); UI.renderBuffs(); }
        requestAnimationFrame(GameLoop.tick);
    }
};

function switchTab(id) {
    document.querySelectorAll('.tab-content').forEach(e=>e.classList.remove('active'));
    document.querySelectorAll('.tab-btn').forEach(e=>e.classList.remove('active'));
    document.getElementById(`tab-${id}`).classList.add('active');
    const idx = ['inventory','tree','shop','crafting','settings'].indexOf(id);
    if(idx > -1) document.querySelectorAll('.tab-btn')[idx].classList.add('active');
    if(id==='inventory') UI.updateInventory();
    
    // Reset confirmation state when switching away
    if(id !== 'settings' && session.resetStage > 0) {
        session.resetStage = 0;
        document.getElementById('reset-btn').innerText = "Reset Everything";
        document.getElementById('reset-btn').style.background = "";
        document.getElementById('reset-btn').style.color = "";
        document.getElementById('reset-warning').classList.remove('visible');
    }
}

window.onload = UI.init;
</script>
</body>
</html>
